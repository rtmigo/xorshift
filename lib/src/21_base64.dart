// SPDX-FileCopyrightText: (c) 2021 Art Galkin <github.com/rtmigo>
// SPDX-License-Identifier: MIT

import '00_ints.dart';
import '21_base32.dart';

/// An abstract base class for generators based on algorithms that output 64-bit integers.
///
/// Overrides some converting methods for cases when 64-bit integers should be handled
/// differently than 32-bit ones.
///
/// Instances of this class can work in Dart Native and VM, but not JavaScript.
abstract class RandomBase64 extends RandomBase32 {
  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 0 to 2^64-1, both inclusive.
  ///
  /// For individual algorithms, these boundaries may actually differ. For example,
  /// algorithms in the Xorshift family never return zero.
  @override
  int nextRaw64();

  /// Generates a non-negative random integer uniformly distributed in the range
  /// from 0 to (2^32)-1, both inclusive.
  ///
  /// The raw numbers generated by the algorithm are 64-bit. This method returns
  /// the upper 32 bits, and then the lower 32 bits of the generated numbers.
  @override
  int nextRaw32() {
    if (!_split64_charged) {
      _split64 = this.nextRaw64();
      _split64_charged = true;

      // returning UPPER four bytes
      const unsignedRightShift = 32;
      return (_split64 >> unsignedRightShift) & ~(-1 << (64 - unsignedRightShift)); // >>>

    } else {
      // we have a value: that means, we're already returned
      // the higher 4 bytes of it. Now we'll return the lower 4 bytes
      final result = _split64 & UINT32_MAX;
      _split64_charged = false; // on the next call we'll need a new random here

      // assert(result != 0); ?!
      assert(result <= 0xFFFFFFFF);
      return result;
    }
  }

  bool _split64_charged = false;
  int _split64 = 0;

  /// Generates a non-negative random floating point value uniformly distributed
  /// in the range from 0.0, inclusive, to 1.0, exclusive.
  ///
  /// To create this number, it takes a 64-bit integer from [nextRaw64] and uses
  /// the highest 53 bits to fill in all the significant bits of the resulting [double].
  ///
  /// By choosing the upper bits, we get rid of the lower bits, which is good.
  /// The lower bits are not so random on many generators.
  ///
  /// This method is [recommended](https://prng.di.unimi.it/) by S. Vigna for
  /// his Xorshift+ and Xoshiro family:
  ///
  /// ```
  /// (in C) 64-bit unsigned integer x should be converted to
  /// a 64-bit double using the expression:
  ///
  ///    (x >> 11) * 0x1.0p-53
  ///
  /// In Java you can use almost the same expression for a (signed)
  /// 64-bit integer:
  ///
  ///    (x >>> 11) * 0x1.0p-53
  /// ```
  @override
  double nextDouble() {
    // Z is the C99's printf("%.60e", 0x1.0p-53):
    const double Z = 1.110223024625156540423631668090820312500000000000000000000000e-16;

    //_____(this.nextInt64()_>>>_11______________________)_*_0x1.0p-53
    return ((this.nextRaw64() >> 11) & ~(-1 << (64 - 11))) * Z;
  }

  @override
  bool nextBool() {
    // we're returning bits from higher to lower
    if (boolCache_prevShift == 0) {
      boolCache = nextRaw64();
      boolCache_prevShift = 63;
      return boolCache < 0; // for the signed integer negative = highest bit set
    } else {
      assert(boolCache_prevShift > 0);
      boolCache_prevShift--;
      final result = (boolCache & (1 << boolCache_prevShift)) != 0;
      return result;
    }
  }

  /// Generates a non-negative random floating point value uniformly distributed
  /// in the range from 0.0, inclusive, to 1.0, exclusive.
  ///
  /// For the Dart this method is slower than [nextDouble] and has no
  /// advantages over [nextDouble].
  ///
  /// The results of this method exactly repeat the numbers usually generated
  /// by algorithms in C99 or C++. For example, this allows you to accurately
  /// reproduce the values of the generator used in the Chrome browser.
  ///
  /// In C99, the type conversion is described by S. Vigna as follows:
  ///
  /// ```
  /// static inline double to_double(uint64_t x) {
  ///   const union { uint64_t i; double d; } u = {
  ///     .i = UINT64_C(0x3FF) << 52 | x >> 12
  ///   };
  ///   return u.d - 1.0;
  /// }
  /// ```
  double nextDoubleBitcast() {
    return super.nextDouble();
    // this is the same as RandomBase32.nextDouble()
    //return nextRaw32() * 2.3283064365386963e-10 + (nextRaw32() >> 12) * 2.220446049250313e-16;
  }
}
